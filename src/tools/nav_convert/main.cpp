// recast_navmesh_to_obj.cpp
// A self-contained CLI to convert a Detour (Recast) navmesh binary
// (in the common RecastDemo "NavMeshSet" format) into a Wavefront OBJ file.
//
// Usage:
//   recast_navmesh_to_obj <input_navmesh.bin> <output.obj> [--with-offmesh]
//
// Build (example):
//   g++ -std=c++17 recast_navmesh_to_obj.cpp -I/path/to/recastdetour/Detour/Include \
//       -L/path/to/lib -ldetour -o recast_navmesh_to_obj
//
// Notes:
// - This loader expects the same serialized layout used by RecastDemo's sample
//   (NavMeshSetHeader + multiple NavMeshTileHeader + raw dtNavMeshData per tile).
// - If your serialization differs, skip the loader and call ExportNavMeshToObj(navMesh, outPath).
// - We export the detailed polygon mesh when available (dtPolyDetail). If detail
//   data is missing, we fall back to a simple fan triangulation of the base polys.
// - Off-mesh connections can optionally be exported as OBJ "l" segments when
//   --with-offmesh is passed.

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <unordered_map>
#include <fstream>
#include <iostream>
#include <sstream>
#include <limits>
#include <cmath>

#include <DetourNavMesh.h>
#include <DetourNavMeshQuery.h>

// ------------------------- Serialization (RecastDemo-style) ------------------

static const int NAVMESHSET_MAGIC = 'M' << 24 | 'S' << 16 | 'E' << 8 | 'T'; // 'MSET'
static const int NAVMESHSET_VERSION = 1;

struct NavMeshSetHeader
{
  int magic;
  int version;
  int numTiles;
  dtNavMeshParams params;
};

struct NavMeshTileHeader
{
  dtTileRef tileRef;
  int dataSize;
};

// ------------------------------ Small Math ----------------------------------
struct Vec3
{
  float x, y, z;
};

static inline bool almostEqual( float a, float b, float eps = 1e-5f ) { return std::fabs( a - b ) <= eps; }

struct VecHash
{
  size_t operator()( const Vec3& v ) const noexcept
  {
    // Quantize to reduce duplicates from tiny float diffs
    auto q = []( float f ) { return static_cast< int >( std::floor( f * 10000.0f + 0.5f ) ); };
    size_t h = 1469598103934665603ull;
    auto mix = [&]( int i )
    {
      h ^= static_cast< size_t >( i );
      h *= 1099511628211ull;
    };
    mix( q( v.x ) );
    mix( q( v.y ) );
    mix( q( v.z ) );
    return h;
  }
};

struct VecEq
{
  bool operator()( const Vec3& a, const Vec3& b ) const noexcept
  {
    return almostEqual( a.x, b.x ) && almostEqual( a.y, b.y ) && almostEqual( a.z, b.z );
  }
};

// --------------------------- OBJ Writer Helper ------------------------------
struct ObjWriter
{
  std::ofstream out;
  std::unordered_map< Vec3, int, VecHash, VecEq > v2i; // 1-based index
  std::vector< Vec3 > verts; // keep for optional later use

  bool open( const std::string& path )
  {
    out.open( path, std::ios::out | std::ios::trunc );
    if( !out ) return false;
    out << "# Generated by recast_navmesh_to_obj\n";
    out << "# vertex positions only (no normals/uvs)\n\n";
    return true;
  }

  int addVertex( const Vec3& v )
  {
    auto it = v2i.find( v );
    if( it != v2i.end() ) return it->second;
    int idx = static_cast< int >( verts.size() ) + 1; // OBJ is 1-based
    v2i.emplace( v, idx );
    verts.push_back( v );
    out << "v " << v.x << ' ' << v.y << ' ' << v.z << "\n";
    return idx;
  }

  void beginObject( const std::string& name )
  {
    out << "\no " << name << "\n";
  }

  void beginGroup( const std::string& name )
  {
    out << "g " << name << "\n";
  }

  void emitTri( int i0, int i1, int i2 )
  {
    out << "f " << i0 << ' ' << i1 << ' ' << i2 << "\n";
  }

  void emitLine( int i0, int i1 )
  {
    out << "l " << i0 << ' ' << i1 << "\n";
  }
};

// ------------------------ Export Core (in-memory) ---------------------------

static void ExportNavMeshToObj( dtNavMesh *nav, const std::string& outPath, bool withOffMesh )
{
  if( !nav )
  {
    throw std::runtime_error( "ExportNavMeshToObj: navmesh is null" );
  }

  ObjWriter w;
  if( !w.open( outPath ) )
  {
    throw std::runtime_error( "Failed to open OBJ for writing: " + outPath );
  }

  const int maxTiles = nav->getMaxTiles();
  w.beginObject( "detour_navmesh" );

  for( int t = 0; t < maxTiles; ++t )
  {
    auto tileRef = nav->encodePolyId(0, t, 0);
    const dtMeshTile *tile = nav->getTileByRef( tileRef );
    if( !tile || !tile->header ) continue;
    const dtMeshHeader *h = tile->header;

    std::ostringstream gname;
    gname << "tile_" << h->x << "_" << h->y;
    w.beginGroup( gname.str() );

    const float *tileVerts = tile->verts; // [vertCount*3]
    const int vertCount = h->vertCount;
    const dtPoly *polys = tile->polys; // [polyCount]
    const int polyCount = h->polyCount;
    const dtPolyDetail *dmeshes = tile->detailMeshes; // [polyCount]
    const float *dverts = tile->detailVerts; // [detailVertsCount*3]
    const unsigned char *dtris = tile->detailTris; // [detailTriCount*4]

    // For mapping base polygon verts to OBJ indices
    auto getBaseVert = [&]( int baseIdx )-> Vec3
    {
      const float *v = &tileVerts[ baseIdx * 3 ];
      return { v[ 0 ], v[ 1 ], v[ 2 ] };
    };

    auto getDetailVert = [&]( int detailIdx )-> Vec3
    {
      const float *v = &dverts[ detailIdx * 3 ];
      return { v[ 0 ], v[ 1 ], v[ 2 ] };
    };

    for( int i = 0; i < polyCount; ++i )
    {
      const dtPoly& p = polys[ i ];
      if( p.getType() != DT_POLYTYPE_GROUND )
      {
        // Skip off-mesh connection polys here; we'll export them separately as lines.
        continue;
      }

      const dtPolyDetail& pd = dmeshes ? dmeshes[ i ] : dtPolyDetail{ 0, 0, 0, 0 };
      bool hasDetail = ( dmeshes && pd.triCount > 0 );

      if( hasDetail )
      {
        // Emit detail tris; indices reference a combined index space:
        // 0..p.vertCount-1 -> base poly verts (tile->verts[p.verts[idx]])
        // p.vertCount.. -> detail verts starting at pd.vertBase
        for( unsigned int tix = 0; tix < pd.triCount; ++tix )
        {
          const unsigned char *tri = &dtris[ ( pd.triBase + tix ) * 4 ];
          int idx[ 3 ];
          for( int k = 0; k < 3; ++k )
          {
            int vi = ( int ) tri[ k ];
            Vec3 v{};
            if( vi < ( int ) p.vertCount )
            {
              v = getBaseVert( p.verts[ vi ] );
            }
            else
            {
              int dvi = pd.vertBase + ( vi - ( int ) p.vertCount );
              v = getDetailVert( dvi );
            }
            idx[ k ] = w.addVertex( v );
          }
          // Winding in Detour detail tris is expected to be CCW in navmesh up-axis.
          w.emitTri( idx[ 0 ], idx[ 1 ], idx[ 2 ] );
        }
      }
      else
      {
        // Fallback: simple fan triangulation of the base polygon.
        // Note: base polys are convex, so fan is safe.
        int n = ( int ) p.vertCount;
        if( n < 3 ) continue;
        int baseIdx0 = w.addVertex( getBaseVert( p.verts[ 0 ] ) );
        for( int k = 1; k < n - 1; ++k )
        {
          int i1 = w.addVertex( getBaseVert( p.verts[ k ] ) );
          int i2 = w.addVertex( getBaseVert( p.verts[ k + 1 ] ) );
          w.emitTri( baseIdx0, i1, i2 );
        }
      }
    }

    if( withOffMesh && tile->header->offMeshConCount > 0 )
    {
      w.beginGroup( gname.str() + "_offmesh" );
      for( int c = 0; c < tile->header->offMeshConCount; ++c )
      {
        const dtOffMeshConnection& con = tile->offMeshCons[ c ];
        Vec3 a{ con.pos[ 0 ], con.pos[ 1 ], con.pos[ 2 ] };
        Vec3 b{ con.pos[ 3 ], con.pos[ 4 ], con.pos[ 5 ] };
        int ia = w.addVertex( a );
        int ib = w.addVertex( b );
        w.emitLine( ia, ib );
      }
    }
  }

  w.out.flush();
}

// ------------------------------ Loader --------------------------------------

static dtNavMesh *LoadNavMesh_RecastDemo( std::istream& is )
{
  NavMeshSetHeader header{};
  is.read( reinterpret_cast< char * >( &header ), sizeof( header ) );
  if( !is ) { throw std::runtime_error( "Failed to read NavMeshSetHeader" ); }
  if( header.magic != NAVMESHSET_MAGIC ) { throw std::runtime_error( "Bad magic (not MSET)" ); }
  if( header.version != NAVMESHSET_VERSION ) { throw std::runtime_error( "Unsupported version" ); }

  dtNavMesh *nav = dtAllocNavMesh();
  if( !nav ) throw std::runtime_error( "dtAllocNavMesh failed" );
  dtStatus status = nav->init( &header.params );
  if( dtStatusFailed( status ) )
  {
    dtFreeNavMesh( nav );
    throw std::runtime_error( "dtNavMesh::init failed" );
  }

  for( int i = 0; i < header.numTiles; ++i )
  {
    NavMeshTileHeader tileHeader{};
    is.read( reinterpret_cast< char * >( &tileHeader ), sizeof( tileHeader ) );
    if( !is ) throw std::runtime_error( "Failed to read NavMeshTileHeader" );
    if( !tileHeader.tileRef || tileHeader.dataSize <= 0 )
    {
      throw std::runtime_error( "Corrupt tile header" );
    }
    unsigned char *data = ( unsigned char * ) dtAlloc( tileHeader.dataSize, DT_ALLOC_PERM );
    if( !data ) throw std::bad_alloc();
    is.read( reinterpret_cast< char * >( data ), tileHeader.dataSize );
    if( !is )
    {
      dtFree( data );
      throw std::runtime_error( "Failed to read tile data block" );
    }
    dtTileRef tileRef = 0;
    dtStatus st = nav->addTile( data, tileHeader.dataSize, DT_TILE_FREE_DATA, tileHeader.tileRef, &tileRef );
    if( dtStatusFailed( st ) )
    {
      dtFree( data ); // addTile failed and didn't take ownership
      throw std::runtime_error( "dtNavMesh::addTile failed" );
    }
  }

  return nav;
}

// ------------------------------ CLI -----------------------------------------

int main( int argc, char **argv )
{
  if( argc < 3 )
  {
    std::cerr << "Usage: " << argv[ 0 ] << " <input_navmesh.bin> <output.obj> [--with-offmesh]\n";
    return 1;
  }

  std::string inPath = argv[ 1 ];
  std::string outPath = argv[ 2 ];
  bool withOffMesh = false;
  if( argc >= 4 && std::string( argv[ 3 ] ) == "--with-offmesh" ) withOffMesh = true;

  try
  {
    std::ifstream ifs( inPath, std::ios::binary );
    if( !ifs )
    {
      std::cerr << "Failed to open input: " << inPath << "\n";
      return 2;
    }
    std::unique_ptr< dtNavMesh, void( * )( dtNavMesh * ) > nav( LoadNavMesh_RecastDemo( ifs ), dtFreeNavMesh );
    ExportNavMeshToObj( nav.get(), outPath, withOffMesh );
    std::cout << "Wrote OBJ: " << outPath << "\n";
  } catch( const std::exception& e )
  {
    std::cerr << "Error: " << e.what() << "\n";
    return 3;
  }
  return 0;
}
